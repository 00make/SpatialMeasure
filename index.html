<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 离线测量工具</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.5);
            font-size: 16px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
            /* 让点击穿透 */
            user-select: none;
        }

        /* 状态显示优化 */
        #status {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
        }

        /* 屏幕右上角的保存按钮（备用） */
        #save-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            z-index: 999;
            pointer-events: auto;
            /* 允许点击 */
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="info">
        <span id="status">准备就绪 - 请点击 "START XR"</span>
        <br>
        <span id="instruction" style="font-size: 12px; color: #ccc;">操作：扳机键打点，两点确定一条线</span>
    </div>

    <button id="save-btn" onclick="downloadCSV()">下载数据</button>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- 1. PWA 离线缓存注册 ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js');
            });
        }

        // --- 2. 核心逻辑 ---
        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // 测量状态变量
        let measureState = 0; // 0: 等待起点, 1: 等待终点
        let startPoint = null;
        let endPoint = null;
        let startCube = null;
        let endCube = null;
        let measureLine = null;

        // 数据存储变量
        let measurementRecords = [];

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            // 关键修复：AR 模式下背景必须是 null (透明)，不能设颜色！
            // scene.background = new THREE.Color(0x333333); <--- 这一行删掉了

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            // 监听 Session 结束事件，自动保存数据
            renderer.xr.addEventListener('sessionend', () => {
                updateStatus("会话结束，正在保存数据...");
                downloadCSV();
            });

            container.appendChild(renderer.domElement);

            // 添加 WebXR 按钮
            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // --- 控制器设置 ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect); // 改回用 select 事件（点击）
            scene.add(controller);

            // 给控制器加个简单的红线，方便看指向
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -0.5)]);
            const line = new THREE.Line(geometry);
            line.scale.z = 5;
            controller.add(line);

            // 初始化测量线对象（一开始隐藏）
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            measureLine = new THREE.Line(lineGeo, lineMat);
            measureLine.frustumCulled = false; // 防止看不见
            scene.add(measureLine);

            window.addEventListener('resize', onWindowResize);

            // 全局暴露下载函数给按钮用
            window.downloadCSV = downloadCSV;
        }

        // --- 核心交互逻辑 ---

        function onSelect() {
            // 获取当前手柄的位置
            const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

            if (measureState === 0) {
                // --- 步骤 1: 放置起点 ---
                cleanScene(); // 清理上一轮的方块

                startPoint = currentPos.clone();
                startCube = createCube(startPoint, 0xff0000); // 红色起点
                scene.add(startCube);

                measureState = 1;
                updateStatus("起点已定，请点击放置终点");

            } else if (measureState === 1) {
                // --- 步骤 2: 放置终点并计算 ---
                endPoint = currentPos.clone();
                endCube = createCube(endPoint, 0x00ff00); // 绿色终点
                scene.add(endCube);

                // 画线
                measureLine.geometry.setFromPoints([startPoint, endPoint]);
                measureLine.visible = true;

                // 执行计算
                const result = calculateData(startPoint, endPoint);

                // 保存数据到内存
                saveToMemory(result);

                // 更新UI显示
                const infoText = `距离: ${result.dist}m | 俯仰: ${result.pitch}° | 方位: ${result.yaw}°`;
                updateStatus(infoText);

                measureState = 0; // 重置状态，准备下一次测量
            }
        }

        // 生成小方块的辅助函数
        function createCube(pos, colorHex) {
            const geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05); // 5cm 方块
            const material = new THREE.MeshBasicMaterial({ color: colorHex });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.copy(pos);
            return cube;
        }

        // 清理场景
        function cleanScene() {
            if (startCube) scene.remove(startCube);
            if (endCube) scene.remove(endCube);
            if (measureLine) measureLine.visible = false;
            startCube = null;
            endCube = null;
        }

        // --- 核心算法 (搬运自你原来的逻辑) ---
        function calculateData(p1, p2) {
            const direction = new THREE.Vector3().subVectors(p2, p1).normalize();

            // 1. 距离
            const dist = p1.distanceTo(p2).toFixed(3);

            // 2. 俯仰角 (Pitch)
            const pitch = THREE.MathUtils.radToDeg(Math.asin(direction.y)).toFixed(2);

            // 3. 方位角 (Yaw)
            const yaw = THREE.MathUtils.radToDeg(Math.atan2(direction.z, direction.x)).toFixed(2);

            return { dist, pitch, yaw };
        }

        function saveToMemory(data) {
            const now = new Date();
            const timeStr = now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds();

            measurementRecords.push({
                time: timeStr,
                distance: data.dist,
                pitch: data.pitch,
                yaw: data.yaw
            });
            console.log("数据已缓存:", measurementRecords);
        }

        // --- 导出 CSV 功能 ---
        function downloadCSV() {
            if (measurementRecords.length === 0) {
                updateStatus("没有数据可下载");
                return;
            }

            let csvContent = "Time,Distance(m),Pitch(deg),Yaw(deg)\n";

            measurementRecords.forEach(row => {
                csvContent += `${row.time},${row.distance},${row.pitch},${row.yaw}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);

            const fileName = `measure_report_${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.csv`;

            link.setAttribute("href", url);
            link.setAttribute("download", fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            updateStatus(`已保存文件: ${fileName}`);
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>