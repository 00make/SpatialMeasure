<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 离线测量工具</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.3);
            font-size: 16px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
        }

        /* 添加一个保存按钮的样式，虽然我们可以在停止时自动保存 */
        #save-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 999;
            pointer-events: auto;
            display: none;
            /* 默认隐藏 */
        }
    </style>
</head>

<body>
    <div id="info">
        <span id="status">准备就绪 (纯前端模式)</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- PWA Service Worker 注册 ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then((reg) => {
                    console.log('离线服务启动成功: ', reg.scope);
                }, (err) => {
                    console.log('离线服务启动失败: ', err);
                });
            });
        }
        // -----------------------------

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // --- 核心变量 ---
        let isMeasuring = false;
        let dataBuffer = []; // 替代 WebSocket，用来在内存中存数据
        const startTime = Date.now(); // 用于记录相对时间

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // 给个背景色，AR模式下会被透视覆盖

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // 添加 WebXR 按钮
            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // --- 控制器设置 ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);

            // 显示控制器模型（简单的射线）
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(geometry);
            line.name = 'line';
            line.scale.z = 5;
            controller.add(line);

            window.addEventListener('resize', onWindowResize);
        }

        // --- 核心逻辑变化 ---

        function onSelectStart() {
            isMeasuring = true;
            dataBuffer = []; // 每次开始测量前清空旧数据（或者你可以选择不清空）
            updateStatus("正在录制数据...");

            // 可以在这里加个视觉反馈，比如方块变色
        }

        function onSelectEnd() {
            isMeasuring = false;
            updateStatus("录制结束，正在保存到头显...");

            // 停止测量时，立即触发下载
            downloadCSV();
        }

        function updateRealtimeData(position) {
            // 这里假设你的业务逻辑是记录位置，你可以根据原来的需求修改字段
            // 模拟原来的数据结构
            const now = new Date();
            const timeStr = now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "." + now.getMilliseconds();

            // 示例数据，你可以根据你的 Cube 逻辑计算 dist/pitch/yaw
            // 这里为了演示，直接存了 position
            const record = {
                timestamp: timeStr,
                x: position.x.toFixed(4),
                y: position.y.toFixed(4),
                z: position.z.toFixed(4)
                // dist, pitch, yaw 等你原来的变量可以加在这里
            };

            // 存入内存数组
            dataBuffer.push(record);
        }

        // --- 生成并下载 CSV 的核心函数 ---
        function downloadCSV() {
            if (dataBuffer.length === 0) {
                updateStatus("没有数据可保存");
                return;
            }

            // 1. 生成 CSV 内容
            // 获取表头 (Keys)
            const keys = Object.keys(dataBuffer[0]);
            let csvContent = keys.join(",") + "\n"; // CSV Header

            // 遍历每一行数据
            dataBuffer.forEach(row => {
                const values = keys.map(k => row[k]);
                csvContent += values.join(",") + "\n";
            });

            // 2. 创建 Blob 对象 (二进制大对象)
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

            // 3. 创建一个临时的 <a> 标签来触发下载
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);

            // 文件名加上时间戳，防止重名
            const fileName = `quest_data_${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.csv`;
            link.setAttribute("download", fileName);

            link.style.visibility = 'hidden';
            document.body.appendChild(link);

            // 4. 触发点击，开始下载
            link.click();

            // 5. 清理
            document.body.removeChild(link);
            updateStatus(`已保存: ${fileName}`);
        }

        function updateStatus(msg) {
            document.getElementById('status').innerHTML = msg;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (isMeasuring && controller) {
                // 获取手柄尖端的实时位置
                const currentControllerPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

                // 存数据
                updateRealtimeData(currentControllerPos);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>