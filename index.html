<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 ç©ºé—´æµ‹é‡ (å¤šçº¿ç¨‹é›¶å¡é¡¿ç‰ˆ)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            font-size: 14px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
            user-select: none;
        }

        #status {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 1px 1px 2px black;
        }

        #file-status {
            margin-top: 5px;
            color: #ffff00;
            font-size: 14px;
        }

        #setup-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: #FF5722;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            z-index: 999;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <button id="setup-btn" onclick="setupFileHandle()">ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©ä¿å­˜æ–‡ä»¶</button>

    <div id="info">
        <div id="status">è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶...</div>
        <div id="file-status">æœªè¿æ¥æ–‡ä»¶</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // -----------------------------------------------------------
        // 1. å®šä¹‰ Worker ä»£ç  (ä½œä¸ºä¸€ä¸ªå­—ç¬¦ä¸² Blobï¼Œé¿å…è·¨åŸŸå’Œæ–‡ä»¶ç®¡ç†éº»çƒ¦)
        // -----------------------------------------------------------
        const workerCode = `
            let fileHandle = null;
            let writable = null;
            let buffer = "";
            let bufferCount = 0;
            const FLUSH_THRESHOLD = 50; // Worker é‡Œå¯ä»¥ç¨å¾®é¢‘ç¹ç‚¹ï¼Œåæ­£ä¸å¡ä¸»çº¿ç¨‹

            self.onmessage = async function(e) {
                const msg = e.data;

                if (msg.type === 'init') {
                    // åˆå§‹åŒ–æ–‡ä»¶æµ
                    try {
                        fileHandle = msg.handle;
                        writable = await fileHandle.createWritable();
                        // å†™å…¥è¡¨å¤´
                        await writable.write("Timestamp,SegmentID,Distance(m),Pitch(deg),Yaw(deg)\\n");
                        self.postMessage({ type: 'status', status: 'ready' });
                    } catch (err) {
                        self.postMessage({ type: 'error', error: err.message });
                    }
                } 
                else if (msg.type === 'data') {
                    // æ¥æ”¶æ•°æ®å¹¶ç¼“å­˜
                    buffer += msg.row;
                    bufferCount++;

                    if (bufferCount >= FLUSH_THRESHOLD) {
                        flush();
                    }
                }
                else if (msg.type === 'close') {
                    // å¼ºåˆ¶å†™å…¥å¹¶å…³é—­
                    await flush();
                    if (writable) await writable.close();
                    self.postMessage({ type: 'status', status: 'closed' });
                }
            };

            async function flush() {
                if (!writable || buffer.length === 0) return;
                const dataToWrite = buffer;
                buffer = "";
                bufferCount = 0;
                try {
                    await writable.write(dataToWrite);
                } catch(e) {
                    console.error("Worker Write Error:", e);
                }
            }
        `;

        // åˆ›å»º Worker å®ä¾‹
        const blob = new Blob([workerCode], { type: "application/javascript" });
        const worker = new Worker(URL.createObjectURL(blob));

        // ç›‘å¬ Worker åé¦ˆ
        worker.onmessage = (e) => {
            if (e.data.type === 'status' && e.data.status === 'closed') {
                alert("å½•åˆ¶ç»“æŸï¼Œæ–‡ä»¶å·²å®‰å…¨ä¿å­˜ã€‚");
                window.location.reload();
            }
            if (e.data.type === 'error') {
                alert("æ–‡ä»¶å†™å…¥é”™è¯¯: " + e.data.error);
            }
        };

        // -----------------------------------------------------------
        // ä¸»ç¨‹åºé€»è¾‘
        // -----------------------------------------------------------

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
        }

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // ä¸šåŠ¡å˜é‡
        let isRecording = false;
        let currentSegmentID = 0;
        let anchorPoint = null;
        let anchorCube = null;
        let endCube = null;
        let dynamicLine = null;
        let directionArrow = null;

        // ä¸´æ—¶å˜é‡ (GCä¼˜åŒ–)
        const _tempVec = new THREE.Vector3();
        const _tempDir = new THREE.Vector3();
        const _cameraPos = new THREE.Vector3();
        const _arrowPos = new THREE.Vector3();
        const _forwardDir = new THREE.Vector3(0, 0, -1);

        // HUD
        let hudSprite = null;
        let hudCanvas, hudContext, hudTexture;

        // çŠ¶æ€æ ‡è®°
        let isFileReady = false;

        let lastRecordTime = 0;
        const RECORD_INTERVAL = 50;

        window.setupFileHandle = setupFileHandle;

        init();
        animate();

        async function setupFileHandle() {
            try {
                const options = {
                    suggestedName: `quest_measure_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-")}.csv`,
                    types: [{ description: 'CSV Files', accept: { 'text/csv': ['.csv'] } }],
                };

                const handle = await window.showSaveFilePicker(options);

                // ã€å…³é”®ã€‘æŠŠ handle å‘é€ç»™ Workerï¼Œä¸»çº¿ç¨‹ä¸å†æŒæœ‰
                worker.postMessage({ type: 'init', handle: handle });

                isFileReady = true;

                document.getElementById('setup-btn').style.display = 'none';
                document.getElementById('file-status').innerText = "å¤šçº¿ç¨‹å†™å…¥æ¨¡å¼ (é«˜æ€§èƒ½)";
                updateStatus("ç¬¬äºŒæ­¥ï¼šç‚¹å‡»ä¸‹æ–¹ START XR è¿›å…¥ VR");

            } catch (err) {
                console.error(err);
                alert("æ–‡ä»¶é…ç½®å¤±è´¥ï¼š" + err.message);
            }
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            renderer.xr.addEventListener('sessionstart', () => {
                if (directionArrow) directionArrow.visible = true;
            });

            renderer.xr.addEventListener('sessionend', () => {
                // å‘Šè¯‰ Worker å…³é—¨é€å®¢
                if (isFileReady) {
                    worker.postMessage({ type: 'close' });
                }
            });

            container.appendChild(renderer.domElement);
            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onTrigger);
            scene.add(controller);

            // è¾…åŠ©çº¿å’Œæ¨¡å‹
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -0.5)]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            controller.add(line);

            directionArrow = new THREE.ArrowHelper(_forwardDir, new THREE.Vector3(0, 1.6, 0), 0.5, 0x00ff00, 0.1, 0.05);
            scene.add(directionArrow);

            const measureLineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const measureLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            dynamicLine = new THREE.Line(measureLineGeo, measureLineMat);
            dynamicLine.frustumCulled = false;
            dynamicLine.visible = false;
            scene.add(dynamicLine);

            initHUD();
            window.addEventListener('resize', onWindowResize);
        }

        function initHUD() {
            hudCanvas = document.createElement('canvas');
            hudCanvas.width = 512;
            hudCanvas.height = 256;
            hudContext = hudCanvas.getContext('2d');
            hudTexture = new THREE.CanvasTexture(hudCanvas);
            hudTexture.generateMipmaps = false;
            hudTexture.minFilter = THREE.LinearFilter;

            const spriteMaterial = new THREE.SpriteMaterial({ map: hudTexture, transparent: true });
            hudSprite = new THREE.Sprite(spriteMaterial);
            hudSprite.scale.set(0.3, 0.15, 1);
            hudSprite.visible = false;
            scene.add(hudSprite);
        }

        function updateHUD(data, position) {
            hudContext.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
            hudContext.fillStyle = 'rgba(0, 0, 0, 0.5)';
            hudContext.roundRect(10, 10, 492, 236, 30);
            hudContext.fill();
            hudContext.fillStyle = '#ffffff';
            hudContext.font = 'bold 50px Arial';
            hudContext.textAlign = 'left';
            hudContext.fillText(`Dist:  ${data.dist} m`, 40, 80);
            hudContext.fillText(`Pitch: ${data.pitch}Â°`, 40, 150);
            hudContext.fillText(`Yaw:   ${data.yaw}Â°`, 40, 220);
            hudTexture.needsUpdate = true;
            hudSprite.position.copy(position);
            hudSprite.position.y += 0.2;
            hudSprite.visible = true;
        }

        function onTrigger() {
            if (!isFileReady) {
                updateStatus("âŒ é”™è¯¯ï¼šæœªè®¾ç½®æ–‡ä»¶ï¼");
                return;
            }

            const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

            if (!isRecording) {
                // === å¼€å§‹ ===
                isRecording = true;
                currentSegmentID++; // çº¿æ®µç¼–å· +1

                disposeObject(anchorCube);
                disposeObject(endCube);
                anchorCube = null;
                endCube = null;

                anchorPoint = currentPos.clone();
                anchorCube = createCube(anchorPoint, 0xff0000);
                scene.add(anchorCube);

                dynamicLine.visible = true;
                updateStatus(`ğŸ”´ å½•åˆ¶ä¸­ (ç¬¬${currentSegmentID}æ¬¡)...`);

            } else {
                // === ç»“æŸ ===
                isRecording = false;
                endCube = createCube(currentPos, 0x00ff00);
                scene.add(endCube);

                updateLine(anchorPoint, currentPos);
                hudSprite.visible = false;

                // Worker ä¼šå¤„ç†å‰©ä¸‹çš„ï¼Œæˆ‘ä»¬åªéœ€è¦æ›´æ–° UI
                updateStatus(`âœ… ç¬¬${currentSegmentID}æ¬¡ä¿å­˜å®Œæˆ`);
            }
        }

        function render() {
            if (directionArrow && directionArrow.visible) {
                camera.getWorldPosition(_cameraPos);
                _arrowPos.set(_cameraPos.x, _cameraPos.y, _cameraPos.z - 2);
                directionArrow.position.copy(_arrowPos);
            }

            if (isRecording && controller && anchorPoint) {
                const now = Date.now();
                _tempVec.setFromMatrixPosition(controller.matrixWorld);

                updateLine(anchorPoint, _tempVec);
                const data = calculateRelativeData(anchorPoint, _tempVec);
                updateHUD(data, _tempVec);

                if (now - lastRecordTime >= RECORD_INTERVAL) {
                    // ã€æ ¸å¿ƒã€‘ç›´æ¥ä¸¢ç»™ Workerï¼Œä¸»çº¿ç¨‹é›¶è´Ÿæ‹…
                    sendDataToWorker(data);
                    lastRecordTime = now;
                }
            }
            renderer.render(scene, camera);
        }

        function sendDataToWorker(data) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-GB') + '.' + String(now.getMilliseconds()).padStart(3, '0');
            // æ„é€ ä¸€è¡Œ CSV å­—ç¬¦ä¸²
            const row = `${timeStr},${currentSegmentID},${data.dist},${data.pitch},${data.yaw}\n`;

            // å‘é€æ¶ˆæ¯
            worker.postMessage({ type: 'data', row: row });
        }

        function calculateRelativeData(pStart, pCurrent) {
            _tempDir.subVectors(pCurrent, pStart);
            const dist = _tempDir.length();
            _tempDir.normalize();
            const pitch = THREE.MathUtils.radToDeg(Math.asin(_tempDir.y));
            const yaw = THREE.MathUtils.radToDeg(Math.atan2(_tempDir.z, _tempDir.x));
            return {
                dist: dist.toFixed(3),
                pitch: pitch.toFixed(1),
                yaw: yaw.toFixed(1)
            };
        }

        function updateLine(p1, p2) {
            const pos = dynamicLine.geometry.attributes.position.array;
            pos[0] = p1.x; pos[1] = p1.y; pos[2] = p1.z;
            pos[3] = p2.x; pos[4] = p2.y; pos[5] = p2.z;
            dynamicLine.geometry.attributes.position.needsUpdate = true;
        }

        function disposeObject(obj) {
            if (!obj) return;
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                else obj.material.dispose();
            }
            scene.remove(obj);
        }

        function createCube(pos, color) {
            const geo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            return mesh;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
    </script>
</body>

</html>