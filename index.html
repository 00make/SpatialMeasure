<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 ç©ºé—´æµ‹é‡ (é«˜æ€§èƒ½ç‰ˆ)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            font-size: 14px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
            user-select: none;
        }

        #status {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 1px 1px 2px black;
        }

        #save-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            z-index: 999;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="status">å°±ç»ª - ç‚¹å‡»æ‰³æœºé”®è®¾å®šé”šç‚¹</div>
    </div>

    <button id="save-btn" onclick="downloadCSV()">ä¸‹è½½æ•°æ®</button>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- Service Worker æ³¨å†Œ ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
        }

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // --- ä¸šåŠ¡å˜é‡ ---
        let isRecording = false;
        let anchorPoint = null;
        let anchorCube = null;
        let endCube = null;
        let dynamicLine = null;
        let directionArrow = null;

        // --- 3D æµ®åŠ¨æ ‡ç­¾å˜é‡ ---
        let hudSprite = null;
        let hudCanvas, hudContext, hudTexture;
        let lastHudUpdateTime = 0; // HUD èŠ‚æµ

        // --- æ•°æ®å½•åˆ¶å˜é‡ ---
        let dataBuffer = [];
        let lastRecordTime = 0;
        const RECORD_INTERVAL = 15;

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šé¢„åˆ†é…ä¸´æ—¶å˜é‡ (é¿å…åœ¨ render ä¸­ new å¯¹è±¡) ---
        const _tempVec3_1 = new THREE.Vector3();
        const _tempVec3_2 = new THREE.Vector3();
        const _tempCameraPos = new THREE.Vector3();
        const _forwardDir = new THREE.Vector3(0, 0, -1);

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            renderer.xr.addEventListener('sessionstart', () => {
                if (directionArrow) directionArrow.visible = true;
            });

            renderer.xr.addEventListener('sessionend', () => {
                if (dataBuffer.length > 0 && !window.hasDownloaded) {
                    downloadCSV();
                    window.hasDownloaded = true;
                }
            });

            container.appendChild(renderer.domElement);

            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // --- æ§åˆ¶å™¨ ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onTrigger);
            scene.add(controller);

            // æ§åˆ¶å™¨å°„çº¿
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -0.5)]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            controller.add(line);

            // --- åˆ›å»ºæ–¹å‘ç®­å¤´ --- 
            // åˆå§‹ä½ç½®è®¾ä¸º 0ï¼Œrender ä¸­ä¼šåŠ¨æ€æ›´æ–°
            directionArrow = new THREE.ArrowHelper(_forwardDir, new THREE.Vector3(0, 0, 0), 0.5, 0x00ff00, 0.1, 0.05);
            scene.add(directionArrow);

            // --- åˆå§‹åŒ–åŠ¨æ€æµ‹é‡çº¿ ---
            // ä¼˜åŒ–ï¼šGeometry è®¾ç½® drawRangeï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—ï¼Œè™½ç„¶è¿™é‡Œåªæœ‰2ä¸ªç‚¹
            const measureLineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const measureLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            dynamicLine = new THREE.Line(measureLineGeo, measureLineMat);
            dynamicLine.frustumCulled = false;
            dynamicLine.visible = false;
            scene.add(dynamicLine);

            initHUD();

            window.addEventListener('resize', onWindowResize);
            window.downloadCSV = downloadCSV;
        }

        function initHUD() {
            hudCanvas = document.createElement('canvas');
            hudCanvas.width = 512;
            hudCanvas.height = 256;
            hudContext = hudCanvas.getContext('2d');
            hudTexture = new THREE.CanvasTexture(hudCanvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: hudTexture, transparent: true });
            hudSprite = new THREE.Sprite(spriteMaterial);
            hudSprite.scale.set(0.3, 0.15, 1);
            hudSprite.visible = false;
            scene.add(hudSprite);
        }

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šHUD æ›´æ–°èŠ‚æµ ---
        function updateHUD(data, position) {
            hudContext.clearRect(0, 0, hudCanvas.width, hudCanvas.height);

            hudContext.fillStyle = 'rgba(0, 0, 0, 0.5)';
            hudContext.roundRect(10, 10, 492, 236, 30);
            hudContext.fill();

            hudContext.fillStyle = '#ffffff';
            hudContext.font = 'bold 50px Arial';
            hudContext.textAlign = 'left';

            hudContext.fillText(`Dist:  ${data.dist} m`, 40, 80);
            hudContext.fillText(`Pitch: ${data.pitch}Â°`, 40, 150);
            hudContext.fillText(`Yaw:   ${data.yaw}Â°`, 40, 220);

            hudTexture.needsUpdate = true; // ä¸Šä¼ çº¹ç†åˆ°GPUï¼Œè¿™æ˜¯ä¸€ä¸ªæ˜‚è´µçš„æ“ä½œ

            hudSprite.position.copy(position);
            hudSprite.position.y += 0.2;
            hudSprite.visible = true;
        }

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šå½»åº•æ¸…ç†èµ„æºçš„å‡½æ•° ---
        function disposeObject(obj) {
            if (!obj) return;

            // 1. ä»åœºæ™¯ç§»é™¤
            scene.remove(obj);

            // 2. é‡Šæ”¾å‡ ä½•ä½“å†…å­˜
            if (obj.geometry) {
                obj.geometry.dispose();
            }

            // 3. é‡Šæ”¾æè´¨å†…å­˜
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            obj = null;
        }

        function onTrigger() {
            // ä½¿ç”¨ä¸´æ—¶å˜é‡ï¼Œå‡å°‘ GC
            _tempVec3_1.setFromMatrixPosition(controller.matrixWorld);

            if (!isRecording) {
                // === å¼€å§‹å½•åˆ¶ ===
                isRecording = true;

                // ä¼˜åŒ–ï¼šæ¸…ç©ºæ•°ç»„ï¼Œå¸®åŠ© GC é‡Šæ”¾ JS å†…å­˜
                dataBuffer.length = 0;

                // ä¼˜åŒ–ï¼šå½»åº•é”€æ¯æ—§å¯¹è±¡ï¼Œé‡Šæ”¾æ˜¾å­˜
                if (anchorCube) {
                    disposeObject(anchorCube);
                    anchorCube = null;
                }
                if (endCube) {
                    disposeObject(endCube);
                    endCube = null;
                }

                anchorPoint = _tempVec3_1.clone(); // è¿™é‡Œå¿…é¡» cloneï¼Œå› ä¸º anchorPoint è¦æŒä¹…ä¿å­˜
                anchorCube = createCube(anchorPoint, 0xff0000);
                scene.add(anchorCube);

                dynamicLine.visible = true;
                updateStatus("ğŸ”´ å½•åˆ¶ä¸­...");

            } else {
                // === ç»“æŸå½•åˆ¶ ===
                isRecording = false;

                endCube = createCube(_tempVec3_1, 0x00ff00);
                scene.add(endCube);

                // åœæ­¢æ—¶æœ€åæ›´æ–°ä¸€æ¬¡çº¿æ®µ
                updateLine(anchorPoint, _tempVec3_1);
                hudSprite.visible = false;

                updateStatus("âœ… å½•åˆ¶å®Œæˆï¼Œæ­£åœ¨ä¸‹è½½...");
                downloadCSV();
                window.hasDownloaded = true;
            }
        }

        function render() {
            const now = Date.now();

            // ä¼˜åŒ–ï¼šä½¿ç”¨ä¸´æ—¶å˜é‡è·å–ç›¸æœºä½ç½®ï¼Œé¿å…æ¯å¸§ new THREE.Vector3()
            if (directionArrow && directionArrow.visible) {
                camera.getWorldPosition(_tempCameraPos);
                // ç®­å¤´åœ¨ç›¸æœºå‰æ–¹ 2 ç±³
                _tempVec3_2.copy(_tempCameraPos).z -= 2;
                directionArrow.position.set(_tempCameraPos.x, _tempCameraPos.y, _tempCameraPos.z - 2);

                // ä¿®æ­£ç®­å¤´é€»è¾‘ï¼šArrowHelper éœ€è¦æ‰‹åŠ¨æ›´æ–°ä½ç½®
                // è¿™é‡Œå…¶å®å¯ä»¥ç›´æ¥æŒ‚è½½åœ¨ Camera ä¸‹é¢ä½œä¸ºå­å¯¹è±¡ï¼Œæ›´çœæ€§èƒ½ï¼Œ
                // ä½†ä¸ºäº†ä¸ç ´åä½ çš„ç°æœ‰é€»è¾‘ç»“æ„ï¼Œæˆ‘ä»¬ä»…ä¼˜åŒ– Vector3 çš„åˆ†é…ã€‚
                directionArrow.position.copy(_tempCameraPos);
                directionArrow.position.z -= 2;
            }

            if (isRecording && controller && anchorPoint) {
                // è·å–æ‰‹æŸ„å½“å‰ä½ç½® (å­˜å…¥ _tempVec3_1)
                _tempVec3_1.setFromMatrixPosition(controller.matrixWorld);

                updateLine(anchorPoint, _tempVec3_1);

                // ä¼˜åŒ–ï¼šHUD æ›´æ–°é¢‘ç‡é™åˆ¶ (èŠ‚æµ)
                // çº¹ç†ä¸Šä¼ å¾ˆè´¹æ€§èƒ½ï¼Œé™åˆ¶åœ¨ 100ms æ›´æ–°ä¸€æ¬¡ (10FPS) å¯¹äººçœ¼è¶³å¤Ÿäº†
                if (now - lastHudUpdateTime > 100) {
                    const data = calculateRelativeData(anchorPoint, _tempVec3_1);
                    updateHUD(data, _tempVec3_1);
                    lastHudUpdateTime = now;
                }

                // æ•°æ®å½•åˆ¶é¢‘ç‡ä¿æŒä¸å˜
                if (now - lastRecordTime >= RECORD_INTERVAL) {
                    const dataForCsv = calculateRelativeData(anchorPoint, _tempVec3_1);
                    saveDataPoint(dataForCsv);
                    lastRecordTime = now;
                }
            }
            renderer.render(scene, camera);
        }

        function calculateRelativeData(pStart, pCurrent) {
            // ä¼˜åŒ–ï¼šä½¿ç”¨ä¸´æ—¶å˜é‡è¿›è¡Œè®¡ç®—
            _tempVec3_2.subVectors(pCurrent, pStart);
            const dist = _tempVec3_2.length();
            _tempVec3_2.normalize();

            const pitch = THREE.MathUtils.radToDeg(Math.asin(_tempVec3_2.y));
            const yaw = THREE.MathUtils.radToDeg(Math.atan2(_tempVec3_2.z, _tempVec3_2.x));

            return {
                dist: dist.toFixed(3),
                pitch: pitch.toFixed(1),
                yaw: yaw.toFixed(1)
            };
        }

        function saveDataPoint(data) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-GB') + '.' + String(now.getMilliseconds()).padStart(3, '0');
            dataBuffer.push({ t: timeStr, ...data });
        }

        function updateLine(p1, p2) {
            const pos = dynamicLine.geometry.attributes.position.array;
            pos[0] = p1.x; pos[1] = p1.y; pos[2] = p1.z;
            pos[3] = p2.x; pos[4] = p2.y; pos[5] = p2.z;
            dynamicLine.geometry.attributes.position.needsUpdate = true;
        }

        function createCube(pos, color) {
            const geo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            return mesh;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function downloadCSV() {
            if (dataBuffer.length === 0) {
                updateStatus("âš ï¸ æ— æ•°æ®");
                return;
            }
            let content = "Timestamp,Distance(m),Pitch(deg),Yaw(deg)\n";
            // ä¼˜åŒ–ï¼šä½¿ç”¨ map å’Œ join æ‹¼æ¥å­—ç¬¦ä¸²é€šå¸¸æ¯” += æ›´å¿«ï¼ˆè™½ç„¶åœ¨è¿™é‡Œå½±å“ä¸å¤§ï¼‰
            content += dataBuffer.map(d => `${d.t},${d.dist},${d.pitch},${d.yaw}`).join('\n');

            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);

            const now = new Date();
            const dateStr = now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0') + '_' +
                String(now.getHours()).padStart(2, '0') + '-' +
                String(now.getMinutes()).padStart(2, '0') + '-' +
                String(now.getSeconds()).padStart(2, '0');

            link.download = `quest_track_${dateStr}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            updateStatus("âœ… å·²ä¿å­˜");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
    </script>
</body>

</html>