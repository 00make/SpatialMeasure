<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 ç¦»çº¿æµ‹é‡å·¥å…· (Pro)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            font-size: 14px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
            user-select: none;
            line-height: 1.5;
            white-space: pre-wrap;
            /* å…è®¸æ¢è¡Œ */
        }

        #status {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
        }

        #realtime-data {
            color: #ffff00;
            font-family: monospace;
            margin-top: 5px;
        }

        /* å¼ºåˆ¶è¦†ç›–å³ä¸Šè§’æŒ‰é’®æ ·å¼ */
        #save-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            z-index: 999;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <div id="info">
        <div id="status">å°±ç»ª - ç‚¹å‡»æ‰³æœºé”®è®¾å®šé”šç‚¹</div>
        <div id="realtime-data">ç­‰å¾…æµ‹é‡...</div>
    </div>

    <button id="save-btn" onclick="downloadCSV()">æ‰‹åŠ¨ä¸‹è½½æ•°æ®</button>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- PWA Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js');
            });
        }

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // --- æ ¸å¿ƒçŠ¶æ€å˜é‡ ---
        let isRecording = false;    // æ˜¯å¦æ­£åœ¨å½•åˆ¶ä¸­
        let anchorPoint = null;     // é”šç‚¹ï¼ˆèµ·ç‚¹/åŸç‚¹ï¼‰
        let anchorCube = null;      // é”šç‚¹çš„è§†è§‰æ–¹å—
        let dynamicLine = null;     // åŠ¨æ€è¿çº¿

        // --- æ•°æ®å½•åˆ¶å˜é‡ ---
        let dataBuffer = [];        // å†…å­˜ä¸­çš„æ•°æ®ç¼“å­˜
        let lastRecordTime = 0;     // ä¸Šä¸€æ¬¡è®°å½•çš„æ—¶é—´æˆ³
        const RECORD_INTERVAL = 50; // æ ¸å¿ƒéœ€æ±‚ï¼š50ms è®°å½•ä¸€æ¬¡

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            // æ³¨æ„ï¼šAR æ¨¡å¼ä¸‹èƒŒæ™¯å¿…é¡»é€æ˜ï¼Œä¸è¦è®¾ç½® scene.background

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            // æ„å¤–é€€å‡º Session æ—¶è‡ªåŠ¨ä¿å­˜
            renderer.xr.addEventListener('sessionend', () => {
                if (dataBuffer.length > 0) {
                    downloadCSV();
                }
            });

            container.appendChild(renderer.domElement);

            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // --- æ§åˆ¶å™¨è®¾ç½® ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onTrigger); // ç»‘å®šæ‰³æœºäº‹ä»¶
            scene.add(controller);

            // æ§åˆ¶å™¨è§†è§‰å°„çº¿
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -0.5)]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            controller.add(line);

            // --- åˆå§‹åŒ–åŠ¨æ€æµ‹é‡çº¿ ---
            // è¿™æ¡çº¿ä¼šä»é”šç‚¹è¿æ¥åˆ°å½“å‰æ‰‹æŸ„ä½ç½®
            const measureLineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const measureLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            dynamicLine = new THREE.Line(measureLineGeo, measureLineMat);
            dynamicLine.frustumCulled = false; // é¿å…è§†è§’å¤–æ¶ˆå¤±
            dynamicLine.visible = false;       // é»˜è®¤éšè—
            scene.add(dynamicLine);

            window.addEventListener('resize', onWindowResize);
            window.downloadCSV = downloadCSV; // æš´éœ²ç»™å…¨å±€æŒ‰é’®
        }

        // --- æ ¸å¿ƒäº¤äº’é€»è¾‘ ---
        function onTrigger() {
            // è·å–å½“å‰æ‰‹æŸ„çš„ä¸–ç•Œåæ ‡
            const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

            if (!isRecording) {
                // === å¼€å§‹å½•åˆ¶ ===
                isRecording = true;
                dataBuffer = []; // æ¸…ç©ºæ—§æ•°æ®

                // 1. è®¾ç½®é”šç‚¹
                anchorPoint = currentPos.clone();

                // 2. ç”Ÿæˆè§†è§‰åé¦ˆï¼ˆçº¢è‰²æ–¹å—ï¼‰
                if (anchorCube) scene.remove(anchorCube);
                anchorCube = createCube(anchorPoint, 0xff0000);
                scene.add(anchorCube);

                // 3. æ˜¾ç¤ºè¿çº¿
                dynamicLine.visible = true;

                updateStatus("ğŸ”´ å½•åˆ¶ä¸­... (æ¯50msé‡‡æ ·)");

            } else {
                // === åœæ­¢å½•åˆ¶ ===
                isRecording = false;

                // 1. æ”¾ç½®ç»ˆç‚¹æ–¹å—ï¼ˆç»¿è‰²ï¼‰ï¼Œæ ‡è®°ç»“æŸä½ç½®
                const endCube = createCube(currentPos, 0x00ff00);
                scene.add(endCube);

                // 2. åœæ­¢è¿çº¿æ›´æ–°ï¼ˆå®šæ ¼ï¼‰
                updateLine(anchorPoint, currentPos);

                updateStatus("âœ… å½•åˆ¶ç»“æŸï¼Œæ­£åœ¨ä¿å­˜...");

                // 3. ç«‹å³ä¸‹è½½æ•°æ®
                downloadCSV();
            }
        }

        // --- æ¯ä¸€å¸§çš„å¾ªç¯é€»è¾‘ ---
        function render() {
            if (isRecording && controller && anchorPoint) {
                const now = Date.now();
                const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

                // 1. è§†è§‰æ›´æ–°ï¼šæ¯ä¸€å¸§éƒ½ç”»çº¿ï¼Œä¿è¯æµç•…
                updateLine(anchorPoint, currentPos);

                // 2. æ•°æ®è®¡ç®—ï¼šè®¡ç®—ç›¸å¯¹é”šç‚¹çš„å…³ç³»
                const data = calculateRelativeData(anchorPoint, currentPos);

                // 3. ç•Œé¢æ›´æ–°ï¼šå®æ—¶æ˜¾ç¤ºæ•°å€¼
                document.getElementById('realtime-data').innerText =
                    `è·ç¦»: ${data.dist}m\nä¿¯ä»°: ${data.pitch}Â°\næ–¹ä½: ${data.yaw}Â°`;

                // 4. æ•°æ®è®°å½•ï¼šæ¯ 50ms å­˜ä¸€æ¬¡ (Throttle)
                if (now - lastRecordTime >= RECORD_INTERVAL) {
                    saveDataPoint(data);
                    lastRecordTime = now;
                }
            }
            renderer.render(scene, camera);
        }

        // --- æ ¸å¿ƒæ•°å­¦è®¡ç®— (å®Œå…¨å¤åˆ» Python é€»è¾‘) ---
        function calculateRelativeData(pStart, pCurrent) {
            // è®¡ç®—æ–¹å‘å‘é‡
            const direction = new THREE.Vector3().subVectors(pCurrent, pStart);
            const dist = direction.length();

            // å½’ä¸€åŒ–ç”¨äºè®¡ç®—è§’åº¦
            direction.normalize();

            // Pitch (ä¿¯ä»°è§’): asin(y)
            const pitch = THREE.MathUtils.radToDeg(Math.asin(direction.y));

            // Yaw (æ–¹ä½è§’): atan2(z, x) -> æ³¨æ„ ThreeJS åæ ‡ç³»
            // é€šå¸¸åœ¨ AR ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®å®é™…é‡åŠ›æ–¹å‘è°ƒæ•´ï¼Œä½†è¿™é‡Œæ²¿ç”¨æ ‡å‡†æ•°å­¦å®šä¹‰
            const yaw = THREE.MathUtils.radToDeg(Math.atan2(direction.z, direction.x));

            return {
                dist: dist.toFixed(4),
                pitch: pitch.toFixed(2),
                yaw: yaw.toFixed(2)
            };
        }

        // --- å†…å­˜æ•°æ®å­˜å‚¨ ---
        function saveDataPoint(data) {
            const now = new Date();
            // ç”Ÿæˆå¸¦æ¯«ç§’çš„æ—¶é—´æˆ³ HH:MM:SS.mmm
            const timeStr = now.toLocaleTimeString('en-GB') + '.' + String(now.getMilliseconds()).padStart(3, '0');

            dataBuffer.push({
                timestamp: timeStr,
                dist: data.dist,
                pitch: data.pitch,
                yaw: data.yaw
            });
        }

        // --- è¾…åŠ©å‡½æ•° ---
        function updateLine(p1, p2) {
            const positions = dynamicLine.geometry.attributes.position.array;
            // èµ·ç‚¹
            positions[0] = p1.x; positions[1] = p1.y; positions[2] = p1.z;
            // ç»ˆç‚¹
            positions[3] = p2.x; positions[4] = p2.y; positions[5] = p2.z;
            dynamicLine.geometry.attributes.position.needsUpdate = true;
        }

        function createCube(pos, color) {
            const geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.copy(pos);
            return cube;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        // --- æ–‡ä»¶å¯¼å‡º ---
        function downloadCSV() {
            if (dataBuffer.length === 0) {
                updateStatus("âš ï¸ æ²¡æœ‰æ•°æ®å¯ä¿å­˜");
                return;
            }

            let csvContent = "Timestamp,Distance(m),Pitch(deg),Yaw(deg)\n";
            dataBuffer.forEach(row => {
                csvContent += `${row.timestamp},${row.dist},${row.pitch},${row.yaw}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");

            const fileName = `quest_track_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-")}.csv`;

            link.href = url;
            link.download = fileName;
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            updateStatus(`âœ… æ•°æ®å·²ä¿å­˜: ${fileName}`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
    </script>
</body>

</html>