<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Quest 3 ç©ºé—´æµ‹é‡ (é«˜æ€§èƒ½é˜²å¡ç‰ˆ)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#333333">
    <link type="text/css" rel="stylesheet" href="./static/css/main.css">
    <style>
        #info {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            font-size: 14px;
            bottom: 20px;
            top: auto;
            pointer-events: none;
            user-select: none;
        }

        #status {
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 1px 1px 2px black;
        }

        #file-status {
            margin-top: 5px;
            color: #ffff00;
            font-size: 14px;
        }

        #setup-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: #FF5722;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            z-index: 999;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <button id="setup-btn" onclick="setupFileHandle()">ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©ä¿å­˜æ–‡ä»¶</button>

    <div id="info">
        <div id="status">è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶...</div>
        <div id="file-status">æœªè¿æ¥æ–‡ä»¶</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./static/build/three.module.js",
                "three/addons/": "./static/jsm/"
            }
        }
    </script>

    <script type="module">
        // Service Worker æ³¨å†Œ
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
        }

        import * as THREE from 'three';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let container;
        let camera, scene, renderer;
        let controller;

        // --- ä¸šåŠ¡å˜é‡ ---
        let isRecording = false;
        let anchorPoint = null;
        let anchorCube = null;
        let endCube = null;
        let dynamicLine = null;
        let directionArrow = null;

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šé¢„åˆ›å»ºçš„ä¸´æ—¶å˜é‡ï¼ˆé¿å…åœ¨ Render å¾ªç¯ä¸­ new å¯¹è±¡ï¼‰ ---
        const _tempVecA = new THREE.Vector3();
        const _tempVecB = new THREE.Vector3();
        const _tempDir = new THREE.Vector3();
        const _cameraPos = new THREE.Vector3();
        const _arrowPos = new THREE.Vector3();
        const _forwardDir = new THREE.Vector3(0, 0, -1);

        // --- 3D HUD ---
        let hudSprite = null;
        let hudCanvas, hudContext, hudTexture;

        // --- ã€å…³é”®ã€‘æµå¼å†™å…¥å˜é‡ ---
        let fileHandle = null;
        let writableStream = null;
        let writeBuffer = "";
        let bufferCount = 0;
        let isWriting = false; // ã€æ–°å¢ã€‘å†™å…¥é”ï¼Œé˜²æ­¢ä»»åŠ¡å †ç§¯
        const BUFFER_FLUSH_THRESHOLD = 200; // ã€è°ƒæ•´ã€‘å¢åŠ ç¼“å†²åŒºå¤§å°ï¼Œå‡å°‘IOé¢‘ç‡

        let lastRecordTime = 0;
        const RECORD_INTERVAL = 50;

        window.setupFileHandle = setupFileHandle;

        init();
        animate();

        async function setupFileHandle() {
            try {
                const options = {
                    suggestedName: `quest_measure_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-")}.csv`,
                    types: [{
                        description: 'CSV Files',
                        accept: { 'text/csv': ['.csv'] },
                    }],
                };

                fileHandle = await window.showSaveFilePicker(options);
                writableStream = await fileHandle.createWritable();
                await writableStream.write("Timestamp,Distance(m),Pitch(deg),Yaw(deg)\n");

                document.getElementById('setup-btn').style.display = 'none';
                document.getElementById('file-status').innerText = "ç¡¬ç›˜ç›´å†™æ¨¡å¼ (å·²ä¼˜åŒ–)";
                updateStatus("ç¬¬äºŒæ­¥ï¼šç‚¹å‡»ä¸‹æ–¹ START XR è¿›å…¥ VR");

            } catch (err) {
                console.error(err);
                alert("æ–‡ä»¶é…ç½®å¤±è´¥ï¼š" + err.message);
            }
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            camera.position.set(0, 1.6, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            renderer.xr.addEventListener('sessionstart', () => {
                if (directionArrow) directionArrow.visible = true;
            });

            renderer.xr.addEventListener('sessionend', async () => {
                if (writableStream) {
                    try {
                        // å¼ºåˆ¶å†™å…¥æœ€åçš„æ•°æ®
                        if (writeBuffer.length > 0) await writableStream.write(writeBuffer);
                        await writableStream.close();
                        alert("å½•åˆ¶ç»“æŸï¼Œæ–‡ä»¶å·²ä¿å­˜ã€‚");
                    } catch (e) { console.error("å…³é—­å¤±è´¥", e); }
                    window.location.reload();
                }
            });

            container.appendChild(renderer.domElement);

            document.body.appendChild(XRButton.createButton(renderer, {
                optionalFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body }
            }));

            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onTrigger);
            scene.add(controller);

            // å°„çº¿
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -0.5)]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            controller.add(line);

            // ç®­å¤´
            directionArrow = new THREE.ArrowHelper(_forwardDir, new THREE.Vector3(0, 1.6, 0), 0.5, 0x00ff00, 0.1, 0.05);
            scene.add(directionArrow);

            // æµ‹é‡çº¿
            const measureLineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const measureLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            dynamicLine = new THREE.Line(measureLineGeo, measureLineMat);
            dynamicLine.frustumCulled = false;
            dynamicLine.visible = false;
            scene.add(dynamicLine);

            initHUD();

            window.addEventListener('resize', onWindowResize);
        }

        function initHUD() {
            hudCanvas = document.createElement('canvas');
            hudCanvas.width = 512;
            hudCanvas.height = 256;
            hudContext = hudCanvas.getContext('2d');
            hudTexture = new THREE.CanvasTexture(hudCanvas);
            // ä¼˜åŒ–ï¼šå…³é—­ mipmaps æé«˜ä¸€ç‚¹æ›´æ–°æ€§èƒ½
            hudTexture.generateMipmaps = false;
            hudTexture.minFilter = THREE.LinearFilter;

            const spriteMaterial = new THREE.SpriteMaterial({ map: hudTexture, transparent: true });
            hudSprite = new THREE.Sprite(spriteMaterial);
            hudSprite.scale.set(0.3, 0.15, 1);
            hudSprite.visible = false;
            scene.add(hudSprite);
        }

        function updateHUD(data, position) {
            hudContext.clearRect(0, 0, hudCanvas.width, hudCanvas.height);

            hudContext.fillStyle = 'rgba(0, 0, 0, 0.5)';
            hudContext.roundRect(10, 10, 492, 236, 30);
            hudContext.fill();

            hudContext.fillStyle = '#ffffff';
            hudContext.font = 'bold 50px Arial';
            hudContext.textAlign = 'left';

            hudContext.fillText(`Dist:  ${data.dist} m`, 40, 80);
            hudContext.fillText(`Pitch: ${data.pitch}Â°`, 40, 150);
            hudContext.fillText(`Yaw:   ${data.yaw}Â°`, 40, 220);

            hudTexture.needsUpdate = true;

            hudSprite.position.copy(position);
            hudSprite.position.y += 0.2;
            hudSprite.visible = true;
        }

        function onTrigger() {
            if (!writableStream) {
                updateStatus("âŒ é”™è¯¯ï¼šæœªè®¾ç½®æ–‡ä»¶ï¼");
                return;
            }

            const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

            if (!isRecording) {
                // === å¼€å§‹ ===
                isRecording = true;
                writeBuffer = "";
                bufferCount = 0;

                // ã€GCä¼˜åŒ–ã€‘å½»åº•é‡Šæ”¾æ—§å¯¹è±¡çš„å†…å­˜
                disposeObject(anchorCube);
                disposeObject(endCube);
                anchorCube = null;
                endCube = null;

                anchorPoint = currentPos.clone();
                anchorCube = createCube(anchorPoint, 0xff0000);
                scene.add(anchorCube);

                dynamicLine.visible = true;
                updateStatus("ğŸ”´ å½•åˆ¶ä¸­...");

            } else {
                // === ç»“æŸ ===
                isRecording = false;
                endCube = createCube(currentPos, 0x00ff00);
                scene.add(endCube);

                updateLine(anchorPoint, currentPos);
                hudSprite.visible = false;

                // å¼ºåˆ¶åˆ·å†™
                flushBufferToDisk(true);
                updateStatus("âœ… å½•åˆ¶ç»“æŸ");
            }
        }

        function render() {
            // --- ç®­å¤´æ›´æ–°ä¼˜åŒ– ---
            if (directionArrow && directionArrow.visible) {
                camera.getWorldPosition(_cameraPos);
                _arrowPos.set(_cameraPos.x, _cameraPos.y, _cameraPos.z - 2);
                directionArrow.position.copy(_arrowPos);
                // æ–¹å‘æ˜¯å›ºå®šçš„ï¼Œä¸éœ€è¦æ¯å¸§é‡æ–°è®¡ç®—
            }

            if (isRecording && controller && anchorPoint) {
                const now = Date.now();
                // ä½¿ç”¨ä¸´æ—¶å˜é‡ï¼Œé¿å… new Vector3
                _tempVecB.setFromMatrixPosition(controller.matrixWorld);

                updateLine(anchorPoint, _tempVecB);
                const data = calculateRelativeData(anchorPoint, _tempVecB);
                updateHUD(data, _tempVecB);

                if (now - lastRecordTime >= RECORD_INTERVAL) {
                    streamDataToDisk(data);
                    lastRecordTime = now;
                }
            }
            renderer.render(scene, camera);
        }

        // --- ã€é‡ç‚¹ä¿®æ”¹ã€‘å¸¦é”çš„æµå¼å†™å…¥ ---
        function streamDataToDisk(data) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-GB') + '.' + String(now.getMilliseconds()).padStart(3, '0');

            const row = `${timeStr},${data.dist},${data.pitch},${data.yaw}\n`;

            writeBuffer += row;
            bufferCount++;

            // ç­–ç•¥è°ƒæ•´ï¼š
            // 1. åªæœ‰å½“ç§¯æ”’äº†è¶³å¤Ÿå¤šçš„æ•°æ® (BUFFER_FLUSH_THRESHOLD)
            // 2. å¹¶ä¸”å½“å‰æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å†™å…¥ä»»åŠ¡ (!isWriting)
            // æ‰ä¼šè§¦å‘å†™å…¥ã€‚
            // å¦åˆ™ï¼Œå°±ç»§ç»­å¾€ buffer é‡Œæ”’ï¼Œç›´åˆ°ä¸Šä¸€æ¬¡å†™å…¥å®Œæˆã€‚
            if (bufferCount >= BUFFER_FLUSH_THRESHOLD && !isWriting) {
                flushBufferToDisk();
            }
        }

        async function flushBufferToDisk(force = false) {
            if (!writableStream || writeBuffer.length === 0) return;
            if (isWriting && !force) return; // å¦‚æœæ­£åœ¨å†™ï¼Œä¸”ä¸æ˜¯å¼ºåˆ¶é€€å‡ºï¼Œåˆ™è·³è¿‡

            try {
                isWriting = true; // ä¸Šé”

                const tempBuffer = writeBuffer;
                writeBuffer = "";
                bufferCount = 0;

                // è¿™æ˜¯ä¸€æ­¥è€—æ—¶æ“ä½œï¼Œå¦‚æœç¡¬ç›˜æ…¢ï¼Œä¼šåœ¨è¿™é‡Œç­‰å¾…
                // ä½†å› ä¸ºæˆ‘ä»¬å·²ç»æŠŠ buffer æ¸…ç©ºå¹¶å­˜å…¥ tempBufferï¼Œ
                // ä¸”æœ‰ isWriting é”ï¼Œæ‰€ä»¥ä¸ä¼šé˜»å¡æ–°æ•°æ®çš„ç§¯æ”’
                await writableStream.write(tempBuffer);

            } catch (err) {
                console.error("å†™å…¥å¤±è´¥:", err);
            } finally {
                isWriting = false; // è§£é”
            }
        }

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šGCå‹å¥½çš„è®¡ç®— ---
        function calculateRelativeData(pStart, pCurrent) {
            // ä½¿ç”¨å…¨å±€ä¸´æ—¶å˜é‡è¿›è¡Œè®¡ç®—ï¼Œä¸äº§ç”Ÿåƒåœ¾å¯¹è±¡
            _tempDir.subVectors(pCurrent, pStart);
            const dist = _tempDir.length();
            _tempDir.normalize();

            const pitch = THREE.MathUtils.radToDeg(Math.asin(_tempDir.y));
            const yaw = THREE.MathUtils.radToDeg(Math.atan2(_tempDir.z, _tempDir.x));

            return {
                dist: dist.toFixed(3),
                pitch: pitch.toFixed(1),
                yaw: yaw.toFixed(1)
            };
        }

        function updateLine(p1, p2) {
            const pos = dynamicLine.geometry.attributes.position.array;
            pos[0] = p1.x; pos[1] = p1.y; pos[2] = p1.z;
            pos[3] = p2.x; pos[4] = p2.y; pos[5] = p2.z;
            dynamicLine.geometry.attributes.position.needsUpdate = true;
        }

        // --- ã€æ–°å¢ã€‘èµ„æºé‡Šæ”¾å‡½æ•° ---
        function disposeObject(obj) {
            if (!obj) return;
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            scene.remove(obj);
        }

        function createCube(pos, color) {
            const geo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            return mesh;
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }
    </script>
</body>

</html>